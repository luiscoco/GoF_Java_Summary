# GoF_Java_Summary

## 1. Module 1

### 1.1 Introduction

**Design patterns** are typical solutions to commonly occurring problems in software design. 

They represent best practices used by experienced object-oriented software developers. 

Understanding these patterns can help you create more flexible, reusable, and maintainable code. 

In this module, we will introduce the concept of design patterns, explore the origins of these patterns, and understand their importance in software development.

### 1.2 Authors and Recommended Reading

The concept of design patterns in software engineering was popularized by the "**Gang of Four" (GoF), consisting of Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides**.

Their book, "**Design Patterns: Elements of Reusable Object-Oriented Software**" is a seminal work in the field. 

For a deeper understanding of design patterns, it is recommended to read the following:

"**Design Patterns**: Elements of Reusable Object-Oriented Software" by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides

"**Head First Design Patterns**" by Eric Freeman and Elisabeth Robson

"**Refactoring**: Improving the Design of Existing Code" by Martin Fowler

"**Clean Code**: A Handbook of Agile Software Craftsmanship" by Robert C. Martin

### 1.3 Object-Oriented Programming (OOP) and UML

**Object-Oriented Programming (OOP)** is a programming paradigm based on the concept of objects, which can contain data and code: data in the form of fields (often known as attributes or properties), 

and code in the form of procedures (often known as methods). 

The key principles of OOP include encapsulation, inheritance, and polymorphism.

**Unified Modeling Language (UML)** is a standardized modeling language that provides a set of graphical notation techniques to create visual models of object-oriented software systems. 

UML is used to specify, visualize, construct, and document the artifacts of software systems. 

Common UML diagrams include:

**Class Diagrams**

**Sequence Diagrams**

**Use Case Diagrams**

**Activity Diagrams**

### 1.4 Principles of Object-Oriented Design

**Object-oriented design principles** help to create a system that is easy to maintain and extend over time

These principles ensure that the software is flexible and can adapt to changes without major rewrites

Some key object-oriented design principles include:

**Encapsulation**: Bundling the data (attributes) and methods (functions) that operate on the data into a single unit or class.

**Abstraction**: Hiding the complex implementation details and showing only the essential features of the object.

**Inheritance**: Mechanism where a new class inherits properties and behavior (methods) from an existing class.

**Polymorphism**: Ability of different objects to respond, each in its own way, to identical messages (or methods).

### 1.5 SOLID Principles

The **SOLID principles** are a set of five design principles intended to make software designs more understandable, flexible, and maintainable.

These principles were introduced by Robert C. Martin and are considered the cornerstone of object-oriented design. The SOLID principles include:

**Single Responsibility Principle (SRP)**: A class should have only one reason to change, meaning it should have only one job or responsibility.

**Open/Closed Principle (OCP)**: Software entities should be open for extension but closed for modification.

**Liskov Substitution Principle (LSP)**: Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

**Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they do not use. Instead of one large interface, multiple smaller interfaces are preferred.

**Dependency Inversion Principle (DIP)**: High-level modules should not depend on low-level modules. 

Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.

By adhering to these principles, developers can create software that is easier to maintain, scale, and refactor.
 
## 2. Module 2:

### 2.1. Singleton

### 2.2. Prototype

### 2.3. Factory Method

### 2.4. Abstract Factory

### 2.5. Builder
 
## 3. Module 3

### 3.1. Adapter

### 3.2. Bridge

### 3.3. Composite

### 3.4. Decorator

### 3.5. Fa√ßade

### 3.6. Flyweight 

### 3.7. Proxy
 
## 4. Module 4

### 4.1. Interpreter

### 4.2. Iterator

### 4.3. Visitor

### 4.4. Observer

### 4.5. Mediator

### 4.6. Memento

### 4.7. Command

### 4.8. Chain of Responsibility
 
### 4.9. Template method

### 4.10. Strategy

### 4.11. State
